RASPI-RED PLANET
================

HECHO
=====
14/05/22 - Cargar mapa de TILED 
14/05/22 - Pintar los tiles de la pantalla a partir de las listas del mapa
16/05/22 - Cargar música (wav->ogg https://audio.online-convert.com/convert-to-ogg)
21/05/22 - Mapeado 1ª parte; superficie
03/06/22 - Filtro Scanlines rápido
09/06/22 - Gestión de textos con gráficos PNG
09/06/22 - Nombres de pantalla
25/06/22 - Mapeado 2ª parte; subsuelo
26/06/22 - Adaptar colores de tiles
25/07/22 - Marcador
27/07/22 - Adaptar las músicas definitivas de tacha a OGG e implementar
31/07/22 - Filtro Scanlines HQ
08/08/22 - Sprites de malotes

EN PROCESO
==========
- Colocación de malotes
- Navegador temporal de mapeado con carga de malotes y objetos

POR HACER
=========
- Obtener SFX de opengameart.com
- Menu inicial con imagen de fondo de MasterKlown
- Movimiento lineal de malotes
- Movimiento diagonal de malotes
- Movimiento flotante de malotes
- Sprite plataforma móvil
- Convertir navegador de mapeado en la opción TOUR-DEMO
- Gestión de teclado (redefinible)
- Teclas especiales; Pause y Mute
- Gestión de Keko; movimiento y saltos
- Tiles pasables, bloqueantes, matantes, y plataformas
- Colisiones entre Keko y malotes
- Keko es invencible los primeros 5 segundos (parpadea)
- Gestión de objetos de tipo TARJETA (abrir puertas)
- Gestión de objetos de tipo EXPLOSIVO
- Gestión de disparos de Keko
- Gestión de objetos de tipo MUNICIÓN
- Gestión de tiempo de oxígeno
- Gestión de objetos de tipo OXÍGENO
- Usar sistema de partículas para explosiones
- Puntos en pantalla de juego
- Bucle de juego, gameover y final
- Pantalla final
- Gestión de pantalla completa (probar en raspberry)
- Comprobación de video acelerado por hardware para compilación condicional
- Revisar, simplificar, organizar y comentar el código fuente final
- Linterna en pantallas oscuras



NOTAS
=====

Gestión del sprite BAT en Sorcerers:
-Se importa de bat.c los dos gráficos (g_bat_0, g_bat_1)

-Se usarán las siguientes constantes
    #define BAT     5
    #define SPR_W 5 // sprite width (bytes)
    #define SPR_H 12 // sprite height (px)

-Se usarán las siguientes enumeraciones
    // sprite movement direction
    enum {D_up, D_down, D_left, D_right} enum_dir;
    // behavior of sprites controlled by CPU
    enum {M_linear_X, M_linear_Y, M_linear_XY, M_chaser} enum_mov;

-Bat será de tipo "TSpr", una estructura con los siguientes datos
	u8 num;		// sprite number (0 to 6; two players and five enemies)
	u8 ident;	// identity; Sorcerer1, Sorcerer2, Sentinel, etc ...
	u8 x, y;	// X, Y coordinates of the sprite
	u8 px, py;	// previous X, Y coordinates of the sprite
	u8 status;	// current status of the sprite; standing, walking, etc ...
	u8 dir;		// sprite direction
	TFrm* frm;	// animation sequence image
	u8 nFrm;	// animation frame number
	u8 lives_speed; // players: lives left.  enemies: speed
	u8 objNum_mov; 	// players: number of ingredients.  enemies: movement type
	u8 print_minV;  // players: need to reprint?.  enemies: minimum XY linear motion
	u8 power_maxV;  // players: powerUp speed*2.  enemies: maximum XY linear motion

-Se crea un array de 7 TSpr, de los cuales, del 2 al 6 serán enemigos

-Se guarda en un array todas las imágenes de BAT
    const TFrm frmBat[2] = {{g_bat_0}, {g_bat_1}};

-Se guarda en un array la animación de BAT
    TFrm* const anim_Bat[2] = {&frmBat[0], &frmBat[1]};

-La función "SelectFrame" asigna un frame o secuencia de frames a cada estado
    if(pSpr->ident == BAT)	AssignFrame(pSpr, anim_Bat);

-La función "AssignFrame" asigna el siguiente frame de la animación
    void AssignFrame(TSpr *pSpr, TFrm **anim) {
	    pSpr->frm = anim[pSpr->nFrm];	
    }

-La función "MoveEnemy" actualiza el valor XY del sprite en función del tipo de movimiento

-La función "SetEnemyparams" ayuda a generar los enemigos de cada pantalla
    void SetEnemyParams(u8 i, u8 ident, u8 mov, u8 dir, u8 speed, u8 x, u8 y, u8 minV, u8 maxV) {
        spr[i].num = i;
        spr[i].ident = ident; 
        spr[i].objNum_mov = mov;	 
        spr[i].dir = dir; 
        spr[i].lives_speed = speed;
        spr[i].x = spr[i].px = x;
        spr[i].y = spr[i].py = y;
        spr[i].print_minV = minV;
        spr[i].power_maxV = maxV;
    }

-La función "SetEnemies" genera los enemigos de cada mapa
    void SetEnemies() {
	    switch (nMap) {
		    case 0: {			 
			    			//SPR IDENTITY	MOVEMENT		DIR     SPEED   X    Y  MIN  MAX
			    SetEnemyParams(2, SENTINEL,	M_linear_X, 	D_left,     1, 73, 158,   2,  73);						
			    SetEnemyParams(3, SENTINEL,	M_linear_X, 	D_right,    1,  3, 110,   2,  73);
			    SetEnemyParams(4, SENTINEL,	M_linear_X, 	D_left,     1, 73,  62,  40,  73);
			    SetEnemyParams(5, SENTINEL,	M_linear_X, 	D_right,    1,  2,  62,   2,  35);
            ...
-En el bucle principal el código para la gestión de cada enemigo sería
    if (pSpr->ident == NOBODY) 
		return; 
	MoveEnemy(pSpr); // update the XY coordinates of the sprite
	SelectFrame(pSpr); // select the animation frame and apply it
	WalkAnim(pSpr, pSpr->dir); 
	DeleteSprite(pSpr); // delete from previous position and paint in the current one
	pSpr->px = pSpr->x; // save the current X coordinate
	pSpr->py = pSpr->y; // save the current Y coordinate
	PrintSprite(pSpr);
	CheckEnemyCollision(0, pSpr); // check if any collision has occurred
